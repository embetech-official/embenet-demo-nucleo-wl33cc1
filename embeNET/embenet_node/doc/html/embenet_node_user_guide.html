<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>embeNET NODE: embeNET Node User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">embeNET NODE<span id="projectnumber">&#160;1.0.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('embenet_node_user_guide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">embeNET Node User Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#embenet_node_networking_basics">Networking basics</a><ul><li class="level2"><a href="#embenet_node_networking_basics_overview">Overview of the network</a></li>
<li class="level2"><a href="#embenet_node_networking_border_router">Border router and nodes</a></li>
<li class="level2"><a href="#embenet_node_networking_joining">The network joining process</a></li>
<li class="level2"><a href="#embenet_node_networking_ipv6">IPv6 and multicast</a></li>
<li class="level2"><a href="#embenet_node_networking_udp">UPD and sockets</a></li>
<li class="level2"><a href="#embenet_node_networking_events">Events and time</a></li>
</ul>
</li>
<li class="level1"><a href="#embenet_node_stack_architecture">Stack architecture</a><ul><li class="level2"><a href="#embenet_node_stack_architecture_general">General information</a></li>
<li class="level2"><a href="#embenet_node_stack_architecture_interfaces">Interfaces</a><ul><li class="level3"><a href="#embenet_node_stack_architecture_node">Node interface</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#embenet_node_stack_handling">Stack handling</a><ul><li class="level2"><a href="#embenet_node_stack_handling_basic">Basic stack handling</a></li>
<li class="level2"><a href="#embenet_node_stack_handling_callbacks">Networking callbacks</a></li>
<li class="level2"><a href="#embenet_node_stack_handling_exceptions">Exception handling</a></li>
</ul>
</li>
<li class="level1"><a href="#embenet_node_network_handling">Network handling</a><ul><li class="level2"><a href="#embenet_node_network_handling_config">Network configuration</a></li>
<li class="level2"><a href="#embenet_node_network_handling_join_rules">Join rules in border router</a></li>
</ul>
</li>
<li class="level1"><a href="#embenet_node_network_handling_joining">Joining the network</a></li>
<li class="level1"><a href="#embenet_node_network_quick_join">Quick join</a></li>
<li class="level1"><a href="#embenet_node_network_leaving">Leaving the network</a></li>
<li class="level1"><a href="#embenet_node_network_handling_events">Event handlers</a></li>
<li class="level1"><a href="#embenet_node_group_handling">Group handling</a></li>
<li class="level1"><a href="#embenet_node_task_handling">Task handling</a><ul><li class="level2"><a href="#embenet_node_task_handling_clocks">Local time and network time</a><ul><li class="level3"><a href="#embenet_node_task_handling_local_time">Local time</a></li>
<li class="level3"><a href="#embenet_node_task_handling_network_time">Network time</a></li>
</ul>
</li>
<li class="level2"><a href="#embenet_node_task_handling_tasks">Scheduling tasks</a></li>
<li class="level2"><a href="#embenet_node_task_handling_differences">Tasks scheduled in network time</a></li>
</ul>
</li>
<li class="level1"><a href="#embenet_node_udp">UDP and sockets</a></li>
<li class="level1"><a href="#embenet_node_random">Random numbers</a></li>
</ul>
</div>
<div class="textblock"><p>This is the embeNET Node User Guide. You can read through the following topics:</p>
<ul>
<li><a class="el" href="embenet_node_user_guide.html#embenet_node_networking_basics">Networking basics</a></li>
<li><a class="el" href="embenet_node_user_guide.html#embenet_node_stack_architecture">Stack architecture</a></li>
<li><a class="el" href="embenet_node_user_guide.html#embenet_node_stack_handling">Stack handling</a></li>
<li><a class="el" href="embenet_node_user_guide.html#embenet_node_network_handling">Network handling</a></li>
<li><a class="el" href="embenet_node_user_guide.html#embenet_node_group_handling">Group handling</a></li>
<li><a class="el" href="embenet_node_user_guide.html#embenet_node_task_handling">Task handling</a></li>
<li><a class="el" href="embenet_node_user_guide.html#embenet_node_udp">UDP and sockets</a></li>
<li><a class="el" href="embenet_node_user_guide.html#embenet_node_random">Random numbers</a></li>
</ul>
<h1><a class="anchor" id="embenet_node_networking_basics"></a>
Networking basics</h1>
<p>The following sections give brief information about the embeNET networking. This is just an overview. Most topics are covered in depth in the following chapters.</p>
<h2><a class="anchor" id="embenet_node_networking_basics_overview"></a>
Overview of the network</h2>
<p>The embeNET network is a wireless mesh network capable of providing communication between hundreds of nodes. It uses a special TSCH (Time Slotted Channel Hopping) scheme for accessing the radio channels, which greatly reduces idle listening and packet collisions even in dense networks. The network works with IEEE 802.15.4 compatible radio transceivers. The network is synchronized meaning that all nodes that joined the same network have a common sense of time, which is very precise and allows the nodes to schedule radio transmission and reception in exact moments.</p>
<h2><a class="anchor" id="embenet_node_networking_border_router"></a>
Border router and nodes</h2>
<p>The embeNET network is started by a special device called border router. Other nodes need to join the network started by the border router in order to be able to communicate. The border router may accept or reject a node based on the specifically configured joining rules.</p>
<h2><a class="anchor" id="embenet_node_networking_joining"></a>
The network joining process</h2>
<p>In order to join a network the node must know the pre-configured network key (K1). This key is shared across all devices within a network and typically can be the same for all devices used in an organization. It is a utility measure and network security is not based on this key. The second key is a pre-shared key (PSK) which is associated with the particular node. It is advised but not mandatory for each node to have a unique pre-shared key.</p>
<p>The joining of node to the network is a multi-step process. Firstly the node synchronizes to the network, meaning that it can follow the scheduled slots in which the communication with other nodes takes place. It selects a node (called pledge) through which it wishes to join. Next it sends credentials including own UID and PSK to the border router, which accepts the node or denies access. Once the node is accepted it can communicate with any other node in the network.</p>
<h2><a class="anchor" id="embenet_node_networking_ipv6"></a>
IPv6 and multicast</h2>
<p>The embeNET network uses the IPv6 protocol for addressing the nodes. It supports multicast addressing mode so that devices can be grouped and the data can be sent to all devices within a group simultaneously. Each device in the network is identified by a 64-bit unique identifier (UID) which is an EUI64 address. In most cases this number comes from the hardware platform the stack works on and should not be altered by the application code. In addition each network started by the border router is identified by a 64-bit network prefix. These two values - the network prefix and the UID are used to form a unicast IPv6 address of the node. A multicast address is being formed by the network prefix and group identifier.</p>
<h2><a class="anchor" id="embenet_node_networking_udp"></a>
UPD and sockets</h2>
<p>The embeNET network uses UDP protocol for transporting data between the nodes. The UDP datagrams are handled by sockets which are registered in the stack.</p>
<h2><a class="anchor" id="embenet_node_networking_events"></a>
Events and time</h2>
<p>The network is synchronized meaning that all nodes that joined the same network have a common sense of time, which is very precise. Thanks to this, the embeNET Node library allows to schedule application-defined events that can be triggered nearly simultaneously in multiple networked nodes. The embeNET Node library allows also to schedule events in local node time, which is not synchronized, but in turn work even if the node is not joined to any network.</p>
<h1><a class="anchor" id="embenet_node_stack_architecture"></a>
Stack architecture</h1>
<h2><a class="anchor" id="embenet_node_stack_architecture_general"></a>
General information</h2>
<p>The embeNET Node library implements a stack of wireless communication protocols that allow the device that runs the stack to communicate in a wireless mesh network. From the user perspective it is a library that provides several interfaces, that the user application (and other middleware - such as network services) can use. However, due to the fact that the library is also portable across multiple hardware platforms, it also relies on some required interfaces. Those need to be implemented in either the 'port' or 'bsp'. Here, we will only focus on the provided interfaces - see <a class="el" href="embenet_node_porting_guide.html">embeNET Node Porting Guide</a> for the description of the required interfaces and how to implement them on a new or custom hardware.</p>
<p>The embeNET Node library utilizes event-driven style of programming. Most actions taken by the node last for a relatively long time before results are observed. Thus many function calls take callbacks as arguments.</p>
<h2><a class="anchor" id="embenet_node_stack_architecture_interfaces"></a>
Interfaces</h2>
<p>The embeNET Node library provides the following interfaces:</p><ul>
<li><a class="el" href="group__embenet__node__api.html">embeNET Node API</a></li>
</ul>
<h3><a class="anchor" id="embenet_node_stack_architecture_node"></a>
Node interface</h3>
<p>The <a class="el" href="group__embenet__node__api.html">embeNET Node API</a> provides a set of functions that allow the stack to initialize and run in the node. It also allows the node to join a specific network that is typically started by a special device called border router. The node can also join several groups which are then addressable through multicast addressing. This interface also allows to schedule user defined tasks that are run in an event-driven fashion in the node.</p>
<h1><a class="anchor" id="embenet_node_stack_handling"></a>
Stack handling</h1>
<h2><a class="anchor" id="embenet_node_stack_handling_basic"></a>
Basic stack handling</h2>
<p>The embeNET Node follows a simple init-proc-deinit rule. Before using the stack you need to initialize the library through a call to <a class="el" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a>. Once the stack is initialized it is expected that the <a class="el" href="group__embenet__node__api.html#gafdaac8d6a93d3b6315ea1e911aa38104">EMBENET_NODE_Proc</a> is called periodically - usually within the main program loop. When (and if) the application is done with the stack it may call <a class="el" href="group__embenet__node__api.html#gad39bafacc3f3647a1a5a9e94ff7b7fc2">EMBENET_NODE_Deinit</a> to deinitialize it.</p>
<p>The following example illustrates the idea:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="node_8h.html">embenet/node.h</a>&gt;</span> <span class="comment">// embeNET Node API</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nodes main function</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">// Initialize embeNET Node</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a>(NULL);</div>
<div class="line">  <span class="keywordflow">while</span>(1) {</div>
<div class="line">    <span class="comment">// Process the embeNET Node stack</span></div>
<div class="line">    <a class="code hl_function" href="group__embenet__node__api.html#gafdaac8d6a93d3b6315ea1e911aa38104">EMBENET_NODE_Proc</a>();</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Deinitialize the stack (if needed)</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#gad39bafacc3f3647a1a5a9e94ff7b7fc2">EMBENET_NODE_Deinit</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__embenet__node__api_html_ga975f34f801e5248f0e2301049a1a141f"><div class="ttname"><a href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a></div><div class="ttdeci">EMBENET_Result EMBENET_NODE_Init(EMBENET_NODE_EventHandlers const *eventHandlers)</div><div class="ttdoc">Initializes the embeNET networking stack for node.</div></div>
<div class="ttc" id="agroup__embenet__node__api_html_gad39bafacc3f3647a1a5a9e94ff7b7fc2"><div class="ttname"><a href="group__embenet__node__api.html#gad39bafacc3f3647a1a5a9e94ff7b7fc2">EMBENET_NODE_Deinit</a></div><div class="ttdeci">void EMBENET_NODE_Deinit(void)</div><div class="ttdoc">Deinitializes the embeNET networking stack.</div></div>
<div class="ttc" id="agroup__embenet__node__api_html_gafdaac8d6a93d3b6315ea1e911aa38104"><div class="ttname"><a href="group__embenet__node__api.html#gafdaac8d6a93d3b6315ea1e911aa38104">EMBENET_NODE_Proc</a></div><div class="ttdeci">void EMBENET_NODE_Proc(void)</div><div class="ttdoc">Runs the networking process of the embeNET stack for node.</div></div>
<div class="ttc" id="anode_8h_html"><div class="ttname"><a href="node_8h.html">node.h</a></div><div class="ttdoc">embeNET Node API</div></div>
</div><!-- fragment --><p>Once the stack is initialized the following elements of the API are available:</p><ul>
<li>network management (see <a class="el" href="embenet_node_user_guide.html#embenet_node_network_handling">Network handling</a>)</li>
<li>group management (see <a class="el" href="embenet_node_user_guide.html#embenet_node_group_handling">Group handling</a>)</li>
<li>task management (see <a class="el" href="embenet_node_user_guide.html#embenet_node_task_handling">Task handling</a>)</li>
<li>utility functions, however some of them may not return valid results until the node joins the network (consult their description)</li>
</ul>
<h2><a class="anchor" id="embenet_node_stack_handling_callbacks"></a>
Networking callbacks</h2>
<p>When networking begins, the stack generates important events that can and should be handled by the application code. These events are handled through callback handlers that are passed the the <a class="el" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a> function. This function accepts a structure that gathers all the handlers which are later called by the stack on specific events. See <a class="el" href="embenet_node_user_guide.html#embenet_node_network_handling">Network handling</a> for the description of the events and the callbacks.</p>
<h2><a class="anchor" id="embenet_node_stack_handling_exceptions"></a>
Exception handling</h2>
<p>There is just one more thing to consider. The embeNET Node stack uses expect_utility for handling input validation and unrecoverable errors. Whenever the stack detects an really faulty condition it calls the EXPECT_OnAbortHandler which must be defined in the user code. The program must not continue operation after calling this function. A typical behavior of such function is to:</p><ul>
<li>go to a safe state</li>
<li>log the error</li>
<li>halt or reset the application</li>
</ul>
<p>Below is the empty implementation of such function that you can copy, paste and extend.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> EXPECT_OnAbortHandler(<span class="keywordtype">char</span> <span class="keyword">const</span>* why, <span class="keywordtype">char</span> <span class="keyword">const</span>* file, <span class="keywordtype">int</span> line) {</div>
<div class="line">    <span class="comment">// TODO</span></div>
<div class="line">    <span class="keywordflow">while</span> (1) { ; }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="embenet_node_network_handling"></a>
Network handling</h1>
<p>Once the embeNET Node is initialized through a call to <a class="el" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a> it is possible to start networking. The following sections will guide you through the topics concerning networking.</p>
<h2><a class="anchor" id="embenet_node_network_handling_config"></a>
Network configuration</h2>
<p>In order to join a network the node should provide three things:</p><ul>
<li>UID - This is the unique node identifier, also called EUI64. This should be unique across the whole device inventory as it identifies the actual piece of hardware the stack runs on. Typically this address should be provided by the hardware and the stack user should not alter it. The application code may get this UID through a call to <a class="el" href="group__embenet__node__api.html#ga51e38fac378ac060d9a2cb8765cf2945">EMBENET_NODE_GetUID</a>. In rare cases the application may want to change the UID. This can be done through a call to <a class="el" href="group__embenet__node__api.html#ga5fc8821266870c22513ee58d6cdcc641">EMBENET_NODE_SetUID</a>, however it is strongly advised not to do so.</li>
<li>network key (K1) - This is a common 128-bit key shared across all the nodes within a single network. This key is not used for security and must be the same in all the nodes wishing to communicate, including the border router.</li>
<li>pre-shared-key (PSK) - This is a device-specific 128-bit key. Depending on the join rule strategy applied in the border router this key can be used to authorize the node in the border router. It is recommended that each node in the network has a different PSK key, as it allows the border router to apply more selective joining process of nodes. The PSK key can be treated as a device signature and should be kept secret.</li>
</ul>
<h2><a class="anchor" id="embenet_node_network_handling_join_rules"></a>
Join rules in border router</h2>
<p>At this point it is worth to mention how network joining rules work in the border router. The border router may apply one of these rules:</p><ul>
<li>every node may join the network - this is useful for development but not for real deployments, due to security concerns</li>
<li>only nodes with matching UIDs may join - this rule only considers UIDs of the nodes and provides very limited security, as the UIDs are visible to the outside world</li>
<li>only nodes with matching PSK may join - this rule only considers pre-shared-keys so that only nodes with matching PSKs can join, which gives reasonable security as PSK should be kept secret</li>
<li>only nodes with matching pairs of UID+PSK can join - this is the most secure node authorization strategy, but requires most preparation in the border router.</li>
</ul>
<p>As a result, employing different PSKs in nodes gives most options in deploying various authorization strategies in the border router.</p>
<h1><a class="anchor" id="embenet_node_network_handling_joining"></a>
Joining the network</h1>
<p>In order to join the network the application should call <a class="el" href="group__embenet__node__api.html#ga8c331022dda56a869e5bd410d8bc2b08">EMBENET_NODE_Join</a> after the stack is initialized. The following example illustrates the idea:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="node_8h.html">embenet/node.h</a>&gt;</span> <span class="comment">// embeNET Node API</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Network key (K1):</span></div>
<div class="line">uint8_t k1[16] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee};</div>
<div class="line"><span class="comment">// Pre-shared key (PSK):</span></div>
<div class="line">uint8_t psk[16] = {0x1b, 0xac, 0xe4, 0x43, 0x41, 0xfd, 0x31, 0x70, 0xab, 0xef, 0xa1, 0x72, 0x99, 0xe1, 0xf3};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Event hander called when node joins network.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> onJoined(<a class="code hl_typedef" href="group__embenet__common.html#ga62e6aadfe9a9ce0c48d06f100408b3d9">EMBENET_PANID</a> panId, <a class="code hl_struct" href="struct_e_m_b_e_n_e_t___n_o_d_e___quick_join_credentials.html">EMBENET_NODE_QuickJoinCredentials</a> <span class="keyword">const</span> *quickJoinCredentials) {</div>
<div class="line">  (void)quickJoinCredentials;</div>
<div class="line">  (void)panId;</div>
<div class="line">  puts(<span class="stringliteral">&quot;This node has joined the network&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nodes main function</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">// Prepare event handlers structure and clear all handlers</span></div>
<div class="line">  <a class="code hl_struct" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html">EMBENET_NODE_EventHandlers</a> eventHandlers = {</div>
<div class="line">      .<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#a25e511aebb58366916c11c60969dc930">onJoined</a> = NULL, .onLeft = NULL, .onJoinAttempt = NULL, .onQuickJoinCredentialsObsolete = NULL, .onDataOnUnregisteredPort = NULL};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set event handler that will be called once the node joins the network</span></div>
<div class="line">  eventHandlers.<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#a25e511aebb58366916c11c60969dc930">onJoined</a> = onJoined;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initialize embeNET Node - pass event handlers</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a>(&amp;eventHandlers);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Prepare configuration structure</span></div>
<div class="line">  <a class="code hl_struct" href="struct_e_m_b_e_n_e_t___n_o_d_e___join_config.html">EMBENET_NODE_JoinConfig</a> config;</div>
<div class="line">  memcpy(config.<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___n_o_d_e___join_config.html#a4aa19b7071553c20719022e9a97ac9f3">k1</a>.<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___k1.html#a89840db9828c6846526c1b821f22ecdf">val</a>, k1, 16);</div>
<div class="line">  memcpy(config.<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___n_o_d_e___join_config.html#af234571c20e084ff22d85e76a8073cd8">psk</a>.<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___p_s_k.html#aa2be0a16d8d6125b221ce9d8c821bbe0">val</a>, psk, 16);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Start the joining process - pass the configuration</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#ga8c331022dda56a869e5bd410d8bc2b08">EMBENET_NODE_Join</a>(&amp;config);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span>(1) {</div>
<div class="line">    <span class="comment">// Process the embeNET Node stack</span></div>
<div class="line">    <a class="code hl_function" href="group__embenet__node__api.html#gafdaac8d6a93d3b6315ea1e911aa38104">EMBENET_NODE_Proc</a>();</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Deinitialize the stack (if needed)</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#gad39bafacc3f3647a1a5a9e94ff7b7fc2">EMBENET_NODE_Deinit</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__embenet__common_html_ga62e6aadfe9a9ce0c48d06f100408b3d9"><div class="ttname"><a href="group__embenet__common.html#ga62e6aadfe9a9ce0c48d06f100408b3d9">EMBENET_PANID</a></div><div class="ttdeci">uint16_t EMBENET_PANID</div><div class="ttdoc">IEEE802.15.4e PAN ID.</div><div class="ttdef"><b>Definition</b> node_defs.h:48</div></div>
<div class="ttc" id="agroup__embenet__node__api_html_ga8c331022dda56a869e5bd410d8bc2b08"><div class="ttname"><a href="group__embenet__node__api.html#ga8c331022dda56a869e5bd410d8bc2b08">EMBENET_NODE_Join</a></div><div class="ttdeci">EMBENET_Result EMBENET_NODE_Join(EMBENET_NODE_JoinConfig const *config)</div><div class="ttdoc">Starts the network joining process as a node.</div></div>
<div class="ttc" id="astruct_e_m_b_e_n_e_t___k1_html_a89840db9828c6846526c1b821f22ecdf"><div class="ttname"><a href="struct_e_m_b_e_n_e_t___k1.html#a89840db9828c6846526c1b821f22ecdf">EMBENET_K1::val</a></div><div class="ttdeci">uint8_t val[16]</div><div class="ttdoc">value</div><div class="ttdef"><b>Definition</b> node_defs.h:63</div></div>
<div class="ttc" id="astruct_e_m_b_e_n_e_t___n_o_d_e___event_handlers_html"><div class="ttname"><a href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html">EMBENET_NODE_EventHandlers</a></div><div class="ttdoc">Structure holding embeNET Node stack event handlers.</div><div class="ttdef"><b>Definition</b> node_event_handlers.h:80</div></div>
<div class="ttc" id="astruct_e_m_b_e_n_e_t___n_o_d_e___event_handlers_html_a25e511aebb58366916c11c60969dc930"><div class="ttname"><a href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#a25e511aebb58366916c11c60969dc930">EMBENET_NODE_EventHandlers::onJoined</a></div><div class="ttdeci">EMBENET_NODE_OnJoined onJoined</div><div class="ttdoc">Event handler that is called when the node joins a given network.</div><div class="ttdef"><b>Definition</b> node_event_handlers.h:82</div></div>
<div class="ttc" id="astruct_e_m_b_e_n_e_t___n_o_d_e___join_config_html"><div class="ttname"><a href="struct_e_m_b_e_n_e_t___n_o_d_e___join_config.html">EMBENET_NODE_JoinConfig</a></div><div class="ttdoc">Structure defining the network configuration.</div><div class="ttdef"><b>Definition</b> node.h:182</div></div>
<div class="ttc" id="astruct_e_m_b_e_n_e_t___n_o_d_e___join_config_html_a4aa19b7071553c20719022e9a97ac9f3"><div class="ttname"><a href="struct_e_m_b_e_n_e_t___n_o_d_e___join_config.html#a4aa19b7071553c20719022e9a97ac9f3">EMBENET_NODE_JoinConfig::k1</a></div><div class="ttdeci">EMBENET_K1 k1</div><div class="ttdoc">Common network key. This key must be the same for all nodes and border router joining the same networ...</div><div class="ttdef"><b>Definition</b> node.h:183</div></div>
<div class="ttc" id="astruct_e_m_b_e_n_e_t___n_o_d_e___join_config_html_af234571c20e084ff22d85e76a8073cd8"><div class="ttname"><a href="struct_e_m_b_e_n_e_t___n_o_d_e___join_config.html#af234571c20e084ff22d85e76a8073cd8">EMBENET_NODE_JoinConfig::psk</a></div><div class="ttdeci">EMBENET_PSK psk</div><div class="ttdoc">Pre-shared key.</div><div class="ttdef"><b>Definition</b> node.h:184</div></div>
<div class="ttc" id="astruct_e_m_b_e_n_e_t___n_o_d_e___quick_join_credentials_html"><div class="ttname"><a href="struct_e_m_b_e_n_e_t___n_o_d_e___quick_join_credentials.html">EMBENET_NODE_QuickJoinCredentials</a></div><div class="ttdoc">Structure describing the data necessary to perform a quick network rejoin.</div><div class="ttdef"><b>Definition</b> node_defs.h:72</div></div>
<div class="ttc" id="astruct_e_m_b_e_n_e_t___p_s_k_html_aa2be0a16d8d6125b221ce9d8c821bbe0"><div class="ttname"><a href="struct_e_m_b_e_n_e_t___p_s_k.html#aa2be0a16d8d6125b221ce9d8c821bbe0">EMBENET_PSK::val</a></div><div class="ttdeci">uint8_t val[16]</div><div class="ttdoc">value</div><div class="ttdef"><b>Definition</b> node_defs.h:68</div></div>
</div><!-- fragment --><p>In the above example, there is just one callback function hooked up as an event handler - EMBENET_NODE_EventHandlers.onJoin. This function will be called when (and only if) the node joins the network with the given configuration options.</p>
<p>Once the <a class="el" href="group__embenet__node__api.html#ga8c331022dda56a869e5bd410d8bc2b08">EMBENET_NODE_Join</a> is called the node enables radio reception listening to the neighboring networks. It then tries to connect to the networks that match the K1 network key. During the join process the node sends authentication data to the border router, which accepts or rejects the node. This process may take a significant amount of time, depending on the network structure and load.</p>
<p>If there is more than one network visible to the node, the node will sequentially try to join each one of them. For each attempt to join a network the stack will call the <a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#abc2df229beeb5976c7ce4b48d3995d9b">EMBENET_NODE_EventHandlers::onJoinAttempt</a> event handler to indicate that a particular network is considered.</p>
<p>The joining process stops only when the node successfully joins to one of the available networks. The join process has no timeout. If the application needs to have such timeout then it should call <a class="el" href="group__embenet__node__api.html#gadfb98213538ebe092e6f5c3037936afc">EMBENET_NODE_Leave</a> after the timeout was reached (see <a class="el" href="embenet_node_user_guide.html#embenet_node_task_handling">Task handling</a> on how such a task can be scheduled).</p>
<p>When the node joins the network, the onJoinCallback function will be called from the context of the <a class="el" href="group__embenet__node__api.html#gafdaac8d6a93d3b6315ea1e911aa38104">EMBENET_NODE_Proc</a> function. This callback will receive the PAN ID identifier that identifies the radio network that the node has joined. In addition the application will receive a set of credentials (<a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___quick_join_credentials.html">EMBENET_NODE_QuickJoinCredentials</a>) that can be used to quickly re-join the same network. See <a class="el" href="embenet_node_user_guide.html#embenet_node_network_quick_join">Quick join</a> for more details.</p>
<p>Once the node has joined the network it is possible to:</p><ul>
<li>obtain the border router IPv6 address through a call to <a class="el" href="group__embenet__node__api.html#ga42eed3ce7c24006439496e5cc757e239">EMBENET_NODE_GetBorderRouterAddress</a></li>
<li>obtain the network time using <a class="el" href="group__embenet__node__api.html#ga9c008a76aae99e3ab34db907f01f8ccf">EMBENET_NODE_GetNetworkTime</a></li>
<li>schedule tasks in network time (see <a class="el" href="embenet_node_user_guide.html#embenet_node_task_handling">Task handling</a>)</li>
</ul>
<h1><a class="anchor" id="embenet_node_network_quick_join"></a>
Quick join</h1>
<p>In some cases joining the network can take a significant amount of time. To speed up this process a quick join technique is introduced. It is particularly useful in cases when the node goes through to reset (either intentional or unintentional) and it would be beneficial to quickly rejoin the network the node was joined to when that happened.</p>
<p>The quick join mechanism relies on the fact that during regular network join the node obtains a set of credentials that are negotiated with the border router. Knowing these credentials allows the node to participate in the network. These credentials (<a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___quick_join_credentials.html">EMBENET_NODE_QuickJoinCredentials</a>) are provided in the <a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#a25e511aebb58366916c11c60969dc930">EMBENET_NODE_EventHandlers::onJoined</a> event callback. The application that wishes to re-use them for quick join should store them in secure, non-volatile memory. Once this is done the next time the node joins the network it is possible to call <a class="el" href="group__embenet__node__api.html#gad5a16be15ac0f146fcb20189295df057">EMBENET_NODE_QuickJoin</a> (instead of <a class="el" href="group__embenet__node__api.html#ga8c331022dda56a869e5bd410d8bc2b08">EMBENET_NODE_Join</a>), providing the recalled credentials.</p>
<p>Once the <a class="el" href="group__embenet__node__api.html#gad5a16be15ac0f146fcb20189295df057">EMBENET_NODE_QuickJoin</a> is called the node tries to join the network matching the credentials. In such a network is found, the process takes up to 1 minute. And if the join succeeded, the <a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#a25e511aebb58366916c11c60969dc930">EMBENET_NODE_EventHandlers::onJoined</a> event handler is called, just like during regular join.</p>
<p>However if the quick join fails to join, it is assumed that the provided credentials became already obsolete. This might happen for example if the whole network is restarted. In such case the <a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#aac20d92f9ce5090a423cd380202735ce">EMBENET_NODE_EventHandlers::onQuickJoinCredentialsObsolete</a> event handler is called, indicating that the stored credentials should probably be forgotten (deleted from the application memory). This however does not stop the join process. The node falls back to the regular join process without any additional user intervention and may receive <a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#a25e511aebb58366916c11c60969dc930">EMBENET_NODE_EventHandlers::onJoined</a> callback if the matching network becomes available.</p>
<p>The following code is an exemplary application of the quick join mechanism.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="node_8h.html">embenet/node.h</a>&gt;</span> <span class="comment">// embeNET Node API</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Network key (K1):</span></div>
<div class="line">uint8_t k1[16] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee};</div>
<div class="line"><span class="comment">// Pre-shared key (PSK):</span></div>
<div class="line">uint8_t psk[16] = {0x1b, 0xac, 0xe4, 0x43, 0x41, 0xfd, 0x31, 0x70, 0xab, 0xef, 0xa1, 0x72, 0x99, 0xe1, 0xf3};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> saveQuickJoinCredentials(<a class="code hl_struct" href="struct_e_m_b_e_n_e_t___n_o_d_e___quick_join_credentials.html">EMBENET_NODE_QuickJoinCredentials</a> <span class="keyword">const</span> *quickJoinCredentials) {</div>
<div class="line">  (void)quickJoinCredentials;</div>
<div class="line">  <span class="comment">// TODO: store quick join credentials to non-volatile memory</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> loadQuickJoinCredentials(<a class="code hl_struct" href="struct_e_m_b_e_n_e_t___n_o_d_e___quick_join_credentials.html">EMBENET_NODE_QuickJoinCredentials</a> <span class="keyword">const</span> *quickJoinCredentials) {</div>
<div class="line">  (void)quickJoinCredentials;</div>
<div class="line">  <span class="comment">// TODO: try to read quick join credentials from non-volatile memory</span></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> clearQuickJoinCredentials(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">// TODO: clear the quick join credentials in the non-volatile memory</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Event hander called when node joins network.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> onJoined(<a class="code hl_typedef" href="group__embenet__common.html#ga62e6aadfe9a9ce0c48d06f100408b3d9">EMBENET_PANID</a> panId, <a class="code hl_struct" href="struct_e_m_b_e_n_e_t___n_o_d_e___quick_join_credentials.html">EMBENET_NODE_QuickJoinCredentials</a> <span class="keyword">const</span> *quickJoinCredentials) {</div>
<div class="line">  (void)panId;</div>
<div class="line">  saveQuickJoinCredentials(quickJoinCredentials);</div>
<div class="line">  puts(<span class="stringliteral">&quot;This node has joined the network&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> onQuickJoinCredentialsObsolete(<span class="keywordtype">void</span>) { clearQuickJoinCredentials(); }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Joins the network either by regular or quick join</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> join(<span class="keywordtype">void</span>) {</div>
<div class="line">  <a class="code hl_struct" href="struct_e_m_b_e_n_e_t___n_o_d_e___quick_join_credentials.html">EMBENET_NODE_QuickJoinCredentials</a> quickJoinCredentials;</div>
<div class="line">  <span class="comment">// Check if we have credentials</span></div>
<div class="line">  <span class="keywordflow">if</span>(loadQuickJoinCredentials(&amp;quickJoinCredentials)) {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Quick joining&quot;</span>);</div>
<div class="line">    <span class="comment">// Start quick join process - pass the credentials</span></div>
<div class="line">    <a class="code hl_function" href="group__embenet__node__api.html#gad5a16be15ac0f146fcb20189295df057">EMBENET_NODE_QuickJoin</a>(&amp;quickJoinCredentials);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Regular joining&quot;</span>);</div>
<div class="line">    <span class="comment">// Prepare configuration structure</span></div>
<div class="line">    <a class="code hl_struct" href="struct_e_m_b_e_n_e_t___n_o_d_e___join_config.html">EMBENET_NODE_JoinConfig</a> config;</div>
<div class="line">    memcpy(config.<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___n_o_d_e___join_config.html#a4aa19b7071553c20719022e9a97ac9f3">k1</a>.<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___k1.html#a89840db9828c6846526c1b821f22ecdf">val</a>, k1, 16);</div>
<div class="line">    memcpy(config.<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___n_o_d_e___join_config.html#af234571c20e084ff22d85e76a8073cd8">psk</a>.<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___p_s_k.html#aa2be0a16d8d6125b221ce9d8c821bbe0">val</a>, psk, 16);</div>
<div class="line">    <span class="comment">// Start the joining process - pass the configuration</span></div>
<div class="line">    <a class="code hl_function" href="group__embenet__node__api.html#ga8c331022dda56a869e5bd410d8bc2b08">EMBENET_NODE_Join</a>(&amp;config);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nodes main function</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">// Prepare event handlers structure</span></div>
<div class="line">  <a class="code hl_struct" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html">EMBENET_NODE_EventHandlers</a> eventHandlers = {</div>
<div class="line">      .<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#a25e511aebb58366916c11c60969dc930">onJoined</a> = NULL, .onLeft = NULL, .onJoinAttempt = NULL, .onQuickJoinCredentialsObsolete = NULL, .onDataOnUnregisteredPort = NULL};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set callback that will be called once the node joins the network</span></div>
<div class="line">  eventHandlers.<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#a25e511aebb58366916c11c60969dc930">onJoined</a> = onJoined;</div>
<div class="line">  <span class="comment">// Set callback that will be called when quick join credentials become obsolete</span></div>
<div class="line">  eventHandlers.<a class="code hl_variable" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#aac20d92f9ce5090a423cd380202735ce">onQuickJoinCredentialsObsolete</a> = onQuickJoinCredentialsObsolete;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initialize embeNET Node - pass event handlers</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a>(&amp;eventHandlers);</div>
<div class="line"> </div>
<div class="line">  join();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span>(1) {</div>
<div class="line">    <span class="comment">// Process the embeNET Node stack</span></div>
<div class="line">    <a class="code hl_function" href="group__embenet__node__api.html#gafdaac8d6a93d3b6315ea1e911aa38104">EMBENET_NODE_Proc</a>();</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Deinitialize the stack (if needed)</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#gad39bafacc3f3647a1a5a9e94ff7b7fc2">EMBENET_NODE_Deinit</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__embenet__node__api_html_gad5a16be15ac0f146fcb20189295df057"><div class="ttname"><a href="group__embenet__node__api.html#gad5a16be15ac0f146fcb20189295df057">EMBENET_NODE_QuickJoin</a></div><div class="ttdeci">EMBENET_Result EMBENET_NODE_QuickJoin(EMBENET_NODE_QuickJoinCredentials const *quickJoinCredentials)</div><div class="ttdoc">Starts the network joining process as a node using a previously stored EMBENET_NODE_QuickJoinCredenti...</div></div>
<div class="ttc" id="astruct_e_m_b_e_n_e_t___n_o_d_e___event_handlers_html_aac20d92f9ce5090a423cd380202735ce"><div class="ttname"><a href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#aac20d92f9ce5090a423cd380202735ce">EMBENET_NODE_EventHandlers::onQuickJoinCredentialsObsolete</a></div><div class="ttdeci">EMBENET_NODE_OnQuickJoinCredentialsObsolete onQuickJoinCredentialsObsolete</div><div class="ttdoc">Event handler that is called when the quick join credentials become obsolete.</div><div class="ttdef"><b>Definition</b> node_event_handlers.h:88</div></div>
</div><!-- fragment --><p>In the above code, after stack initialization (<a class="el" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a>) the 'join' function is called. This function checks if there are any quick join credentials stored. If so it starts the quick join mechanism and calling the <a class="el" href="group__embenet__node__api.html#gad5a16be15ac0f146fcb20189295df057">EMBENET_NODE_QuickJoin</a> function. If not a regular join (<a class="el" href="group__embenet__node__api.html#ga8c331022dda56a869e5bd410d8bc2b08">EMBENET_NODE_Join</a>) is performed. In any case if the join is successful the <a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#a25e511aebb58366916c11c60969dc930">EMBENET_NODE_EventHandlers::onJoined</a> event handler is called and the new credentials are stored. However if the quick join is performed and it fails, the <a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#aac20d92f9ce5090a423cd380202735ce">EMBENET_NODE_EventHandlers::onQuickJoinCredentialsObsolete</a> is called where the stored credentials should be cleared.</p>
<p>Note, that in the above code the 'saveQuickJoinCredentials', 'loadQuickJoinCredentials' and 'clearQuickJoinCredentials' need to be implemented for the given hardware platform. <br  />
</p>
<h1><a class="anchor" id="embenet_node_network_leaving"></a>
Leaving the network</h1>
<p>If the application wishes to leave the network it should call <a class="el" href="group__embenet__node__api.html#gadfb98213538ebe092e6f5c3037936afc">EMBENET_NODE_Leave</a>. As a result all network activity of the node will be stopped. In addition, if the node was joined to the network then all the tasks that were scheduled in network time get canceled. This call can also be used to stop the on-going joining process.</p>
<p>Leaving the network can also be caused by external conditions. If the node permanently looses wireless connection to other nodes it will in turn leave the network automatically. <br  />
</p>
<p>In any case, if the node was joined and then left the network (either by a call to <a class="el" href="group__embenet__node__api.html#gadfb98213538ebe092e6f5c3037936afc">EMBENET_NODE_Leave</a> or due to external circumstances causes it to leave the network then the <a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#aab1e214bf62e6c6854e52d406f14387b">EMBENET_NODE_EventHandlers::onLeft</a> event handler will be called.</p>
<h1><a class="anchor" id="embenet_node_network_handling_events"></a>
Event handlers</h1>
<p>The <a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html">EMBENET_NODE_EventHandlers</a> structure gathers all the event handlers. During stack initialization this structure is passed to the <a class="el" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a> function. If a particular event handler is not used it should be set to NULL. <br  />
 The following table lists all the event handlers with their description:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Event handler   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#a25e511aebb58366916c11c60969dc930">EMBENET_NODE_EventHandlers::onJoined</a>   </td><td class="markdownTableBodyNone">Called when the node joins a network (see <a class="el" href="embenet_node_user_guide.html#embenet_node_network_handling_joining">Joining the network</a>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#aab1e214bf62e6c6854e52d406f14387b">EMBENET_NODE_EventHandlers::onLeft</a>   </td><td class="markdownTableBodyNone">Called when the node leaves a network (see <a class="el" href="embenet_node_user_guide.html#embenet_node_network_leaving">Leaving the network</a>)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#abc2df229beeb5976c7ce4b48d3995d9b">EMBENET_NODE_EventHandlers::onJoinAttempt</a>   </td><td class="markdownTableBodyNone">Called when the node attempts to join a network (see <a class="el" href="embenet_node_user_guide.html#embenet_node_network_handling_joining">Joining the network</a>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#aac20d92f9ce5090a423cd380202735ce">EMBENET_NODE_EventHandlers::onQuickJoinCredentialsObsolete</a>   </td><td class="markdownTableBodyNone">Called when the credentials used for quick join become obsolete (see <a class="el" href="embenet_node_user_guide.html#embenet_node_network_quick_join">Quick join</a>)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="struct_e_m_b_e_n_e_t___n_o_d_e___event_handlers.html#a0694964bc576c5a77968f20d47a76bae">EMBENET_NODE_EventHandlers::onDataOnUnregisteredPort</a>   </td><td class="markdownTableBodyNone">Called when an UDP datagram is received but no socket can handle it   </td></tr>
</table>
<h1><a class="anchor" id="embenet_node_group_handling"></a>
Group handling</h1>
<p>Nodes can be organized in groups. The idea is to enable multicast addressing of such a group so that UDP packets can be sent to all the members of the group simultaneously. It is the node that decides to which groups it belongs to. The border router only observes the grouping behavior of nodes and can list all the group members, but it cannot directly make a given node join or leave particular group.</p>
<p>Each group is identified by a EMBENET_GroupId group identifier, which is freely chosen by the nodes.</p>
<p>In order to join a given group the nodes application should use <a class="el" href="group__embenet__node__api.html#gaccee999902a31da8fa227a730ddc8ce4">EMBENET_NODE_JoinGroup</a> after the stack was initialized. Node can join multiple groups by subsequently calling the <a class="el" href="group__embenet__node__api.html#gaccee999902a31da8fa227a730ddc8ce4">EMBENET_NODE_JoinGroup</a> function.</p>
<p>The node may also leave particular group using <a class="el" href="group__embenet__node__api.html#gab06fa5e3402729d3dc84c501ca84ab1b">EMBENET_NODE_LeaveGroup</a> function.</p>
<p>At any time after stack initialization the nodes application can get the number of groups it belongs to using <a class="el" href="group__embenet__node__api.html#gaf207d2f21e6c3cf2d68441fc93a1c0a4">EMBENET_NODE_GetGroupCount</a>. Next, it is possible to get group identifiers the node belongs to by calling <a class="el" href="group__embenet__node__api.html#ga773cc3e9630e945175de25aac972de32">EMBENET_NODE_GetGroupByIndex</a> with index starting from 0 to the value returned by <a class="el" href="group__embenet__node__api.html#gaf207d2f21e6c3cf2d68441fc93a1c0a4">EMBENET_NODE_GetGroupCount</a> - 1.</p>
<p>The example below illustrates this API usage:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="node_8h.html">embenet/node.h</a>&gt;</span> <span class="comment">// embeNET Node API</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nodes main function</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">// Initialize embeNET Node</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a>(NULL);</div>
<div class="line">  <span class="comment">// Join groups 13 and 27</span></div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">false</span> == <a class="code hl_function" href="group__embenet__node__api.html#gaccee999902a31da8fa227a730ddc8ce4">EMBENET_NODE_JoinGroup</a>(13)) {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Failed to join group 13&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(<span class="keyword">false</span> == <a class="code hl_function" href="group__embenet__node__api.html#gaccee999902a31da8fa227a730ddc8ce4">EMBENET_NODE_JoinGroup</a>(27)) {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Failed to join group 27&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get number of groups the node belongs to</span></div>
<div class="line">  <span class="keywordtype">size_t</span> groupCount = <a class="code hl_function" href="group__embenet__node__api.html#gaf207d2f21e6c3cf2d68441fc93a1c0a4">EMBENET_NODE_GetGroupCount</a>(); <span class="comment">// this should return 2</span></div>
<div class="line">  <span class="comment">// Go through all indexes</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> groupIndex = 0; groupIndex &lt; groupCount; groupIndex++) {</div>
<div class="line">    <span class="comment">// Get groupId</span></div>
<div class="line">    EMBENET_GroupId groupId = <a class="code hl_function" href="group__embenet__node__api.html#ga773cc3e9630e945175de25aac972de32">EMBENET_NODE_GetGroupByIndex</a>(groupIndex);</div>
<div class="line">    printf(<span class="stringliteral">&quot;I&#39;m in group: %d &quot;</span>, (<span class="keywordtype">int</span>)groupId);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span>(1) {</div>
<div class="line">    <span class="comment">// Process the embeNET Node stack</span></div>
<div class="line">    <a class="code hl_function" href="group__embenet__node__api.html#gafdaac8d6a93d3b6315ea1e911aa38104">EMBENET_NODE_Proc</a>();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Deinitialize the stack (if needed)</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#gad39bafacc3f3647a1a5a9e94ff7b7fc2">EMBENET_NODE_Deinit</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__embenet__node__api_html_ga773cc3e9630e945175de25aac972de32"><div class="ttname"><a href="group__embenet__node__api.html#ga773cc3e9630e945175de25aac972de32">EMBENET_NODE_GetGroupByIndex</a></div><div class="ttdeci">EMBENET_GroupId EMBENET_NODE_GetGroupByIndex(size_t index)</div><div class="ttdoc">Gets the groups the node belongs to by their index.</div></div>
<div class="ttc" id="agroup__embenet__node__api_html_gaccee999902a31da8fa227a730ddc8ce4"><div class="ttname"><a href="group__embenet__node__api.html#gaccee999902a31da8fa227a730ddc8ce4">EMBENET_NODE_JoinGroup</a></div><div class="ttdeci">bool EMBENET_NODE_JoinGroup(EMBENET_GroupId groupId)</div><div class="ttdoc">Makes the node join the given multicast group.</div></div>
<div class="ttc" id="agroup__embenet__node__api_html_gaf207d2f21e6c3cf2d68441fc93a1c0a4"><div class="ttname"><a href="group__embenet__node__api.html#gaf207d2f21e6c3cf2d68441fc93a1c0a4">EMBENET_NODE_GetGroupCount</a></div><div class="ttdeci">size_t EMBENET_NODE_GetGroupCount(void)</div><div class="ttdoc">Gets the number of groups the node belongs to.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="embenet_node_task_handling"></a>
Task handling</h1>
<p>The embeNET Node library provides additional scheduling mechanism that allows to run application code callbacks from the context of the <a class="el" href="group__embenet__node__api.html#gafdaac8d6a93d3b6315ea1e911aa38104">EMBENET_NODE_Proc</a> at a given time. This is useful for implementing periodic behavior such as gathering data from sensors or sending it to the network.</p>
<h2><a class="anchor" id="embenet_node_task_handling_clocks"></a>
Local time and network time</h2>
<p>The embeNET Node library uses two notions of time - local time and network time.</p>
<h3><a class="anchor" id="embenet_node_task_handling_local_time"></a>
Local time</h3>
<p>Local time is the time taken from a clock that starts to run once the embeNET Node stack is initialized by the <a class="el" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a> function. This clock ticks in milliseconds from 0 until the <a class="el" href="group__embenet__node__api.html#gad39bafacc3f3647a1a5a9e94ff7b7fc2">EMBENET_NODE_Deinit</a> is called. This time can be accessed through a call to <a class="el" href="group__embenet__node__api.html#gad6507236a07521ade7b30cfdaa418ff6">EMBENET_NODE_GetLocalTime</a> and it has 64-bit resolution.</p>
<h3><a class="anchor" id="embenet_node_task_handling_network_time"></a>
Network time</h3>
<p>In embeNET, every node connected to the network is synchronized to the common network time. The origin of this network clock is the border router. Network time is accessible to the node'a application after the node synchronizes to a network. It can be read through a call to <a class="el" href="group__embenet__node__api.html#ga9c008a76aae99e3ab34db907f01f8ccf">EMBENET_NODE_GetNetworkTime</a>. The network time accessible to the application in measured in milliseconds with 64-bit resolution. Due to security concerns, the network time does not start from zero, but from a random value established at the border router. It is important to node that this time 'flows' only for nodes that are synchronized to the network. If a node desynchronizes - for example leaves the network - then the* network time in that node stops. If the node synchronizes again to the same network then the network time may already have a larger value. Moreover, if the node synchronizes to different network or the network is restarted, the network time may have a completely different (even earlier) value.</p>
<h2><a class="anchor" id="embenet_node_task_handling_tasks"></a>
Scheduling tasks</h2>
<p>The embeNET Node library uses an abstraction of task. Once the stack is initialized by the <a class="el" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a> function, a task can be created using <a class="el" href="group__embenet__node__api.html#ga94fee61d254b860dcb83f1c3baa37456">EMBENET_NODE_TaskCreate</a>. The function accepts two arguments:</p><ul>
<li>the actual function to call as task implementation,</li>
<li>a user-defined context that will be passed to the task implementation function once it gets called.</li>
</ul>
<p>The created task is identified by the <a class="el" href="group__embenet__node__api.html#gabee561bfb171826daed0855e73db97e4">EMBENET_TaskId</a> value - a task identifier. The stack can only handle a limited number of tasks, so if EMBENET_NODE_TaskCreate returns <a class="el" href="group__embenet__node__api.html#ga5b631f029e6959c0b2e89874e65f82ec">EMBENET_TASKID_INVALID</a> then no more task can be created.</p>
<p>Once the task is created it can be scheduled to run at a given time - local time or network time - using <a class="el" href="group__embenet__node__api.html#ga5a3cc93daabc2f52738fb471dc4b4401">EMBENET_NODE_TaskSchedule</a> function. When the actual time comes, the task will be run from the <a class="el" href="group__embenet__node__api.html#gafdaac8d6a93d3b6315ea1e911aa38104">EMBENET_NODE_Proc</a> function.</p>
<p>The following example illustrates the task API:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="node_8h.html">embenet/node.h</a>&gt;</span> <span class="comment">// embeNET Node API</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> myTaskFunction(<a class="code hl_typedef" href="group__embenet__node__api.html#gabee561bfb171826daed0855e73db97e4">EMBENET_TaskId</a> taskId, <a class="code hl_enumeration" href="group__embenet__node__api.html#ga8bde2931321b4a3f4f97ba7489e9aa24">EMBENET_NODE_TimeSource</a> timeSource, uint64_t t, <span class="keywordtype">void</span> *context) {</div>
<div class="line">  printf(<span class="stringliteral">&quot;Task was called, context is: %s&quot;</span>, (<span class="keywordtype">char</span> *)context);</div>
<div class="line">  <span class="comment">// reschedule the task after another 5 seconds</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#ga5a3cc93daabc2f52738fb471dc4b4401">EMBENET_NODE_TaskSchedule</a>(taskId, timeSource, t + 5000);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">char</span> *myContext = (<span class="keywordtype">char</span> *)<span class="stringliteral">&quot;MyContext&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nodes main function</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">// Initialize embeNET Node</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#ga975f34f801e5248f0e2301049a1a141f">EMBENET_NODE_Init</a>(NULL);</div>
<div class="line">  <span class="comment">// Create a task</span></div>
<div class="line">  <a class="code hl_typedef" href="group__embenet__node__api.html#gabee561bfb171826daed0855e73db97e4">EMBENET_TaskId</a> taskId = <a class="code hl_function" href="group__embenet__node__api.html#ga94fee61d254b860dcb83f1c3baa37456">EMBENET_NODE_TaskCreate</a>(myTaskFunction, myContext);</div>
<div class="line">  <span class="comment">// Schedule the task to run 10 seconds after initialization</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#ga5a3cc93daabc2f52738fb471dc4b4401">EMBENET_NODE_TaskSchedule</a>(taskId, <a class="code hl_enumvalue" href="group__embenet__node__api.html#gga8bde2931321b4a3f4f97ba7489e9aa24ac1b9775010a4d0f8c27966de5f57706f">EMBENET_NODE_TIME_SOURCE_LOCAL</a>, 10000);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span>(1) {</div>
<div class="line">    <span class="comment">// Process the embeNET Node stack</span></div>
<div class="line">    <a class="code hl_function" href="group__embenet__node__api.html#gafdaac8d6a93d3b6315ea1e911aa38104">EMBENET_NODE_Proc</a>();</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Destroy the task (if needed)</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#gad656682913db2de324cbe0b2a75754ba">EMBENET_NODE_TaskDestroy</a>(taskId);</div>
<div class="line">  <span class="comment">// Deinitialize the stack (if needed)</span></div>
<div class="line">  <a class="code hl_function" href="group__embenet__node__api.html#gad39bafacc3f3647a1a5a9e94ff7b7fc2">EMBENET_NODE_Deinit</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__embenet__node__api_html_ga5a3cc93daabc2f52738fb471dc4b4401"><div class="ttname"><a href="group__embenet__node__api.html#ga5a3cc93daabc2f52738fb471dc4b4401">EMBENET_NODE_TaskSchedule</a></div><div class="ttdeci">EMBENET_Result EMBENET_NODE_TaskSchedule(EMBENET_TaskId taskId, EMBENET_NODE_TimeSource timeSource, uint64_t t)</div><div class="ttdoc">Schedules task in time, reschedules if task was already scheduled.</div></div>
<div class="ttc" id="agroup__embenet__node__api_html_ga8bde2931321b4a3f4f97ba7489e9aa24"><div class="ttname"><a href="group__embenet__node__api.html#ga8bde2931321b4a3f4f97ba7489e9aa24">EMBENET_NODE_TimeSource</a></div><div class="ttdeci">EMBENET_NODE_TimeSource</div><div class="ttdoc">Possible time sources for task scheduling.</div><div class="ttdef"><b>Definition</b> node.h:192</div></div>
<div class="ttc" id="agroup__embenet__node__api_html_ga94fee61d254b860dcb83f1c3baa37456"><div class="ttname"><a href="group__embenet__node__api.html#ga94fee61d254b860dcb83f1c3baa37456">EMBENET_NODE_TaskCreate</a></div><div class="ttdeci">EMBENET_TaskId EMBENET_NODE_TaskCreate(EMBENET_NODE_TaskFunction taskFunction, void *userContext)</div><div class="ttdoc">Registers an application-level task.</div></div>
<div class="ttc" id="agroup__embenet__node__api_html_gabee561bfb171826daed0855e73db97e4"><div class="ttname"><a href="group__embenet__node__api.html#gabee561bfb171826daed0855e73db97e4">EMBENET_TaskId</a></div><div class="ttdeci">uint32_t EMBENET_TaskId</div><div class="ttdoc">Identifier of an application-level task running within the stack.</div><div class="ttdef"><b>Definition</b> node.h:187</div></div>
<div class="ttc" id="agroup__embenet__node__api_html_gad656682913db2de324cbe0b2a75754ba"><div class="ttname"><a href="group__embenet__node__api.html#gad656682913db2de324cbe0b2a75754ba">EMBENET_NODE_TaskDestroy</a></div><div class="ttdeci">EMBENET_Result EMBENET_NODE_TaskDestroy(EMBENET_TaskId taskId)</div><div class="ttdoc">Destroys a task.</div></div>
<div class="ttc" id="agroup__embenet__node__api_html_gga8bde2931321b4a3f4f97ba7489e9aa24ac1b9775010a4d0f8c27966de5f57706f"><div class="ttname"><a href="group__embenet__node__api.html#gga8bde2931321b4a3f4f97ba7489e9aa24ac1b9775010a4d0f8c27966de5f57706f">EMBENET_NODE_TIME_SOURCE_LOCAL</a></div><div class="ttdeci">@ EMBENET_NODE_TIME_SOURCE_LOCAL</div><div class="ttdoc">Local node time.</div><div class="ttdef"><b>Definition</b> node.h:194</div></div>
</div><!-- fragment --><p>It is worth to mention, that it is relatively easy to reschedule the task that was run inside the task callback function, as shown in the above example.</p>
<p>It is possible to cancel the scheduled task using <a class="el" href="group__embenet__node__api.html#gac9c922cd0b4b800112f835c3c6bb8029">EMBENET_NODE_TaskCancel</a>. Such tasks can be scheduled to run later.</p>
<p>When the task is not needed, it can be destroyed by a call to <a class="el" href="group__embenet__node__api.html#gad656682913db2de324cbe0b2a75754ba">EMBENET_NODE_TaskDestroy</a>, however the taskId may be reused by the stack when another task is created.</p>
<h2><a class="anchor" id="embenet_node_task_handling_differences"></a>
Tasks scheduled in network time</h2>
<p>The tasks that are scheduled in the same network time are invoked synchronously across all the nodes that scheduled them. This opens the opportunity to implement precise synchronous behavior in many networked nodes. However the drawback is that if the node desynchronizes from the network, the events scheduled in network time get canceled automatically and may need to be rescheduled once the node synchronizes again.</p>
<h1><a class="anchor" id="embenet_node_udp"></a>
UDP and sockets</h1>
<p>For the description of the UDP and sockets refer to embenet_udp_using_sockets.</p>
<h1><a class="anchor" id="embenet_node_random"></a>
Random numbers</h1>
<p>In many cases, internally the embeNET Node library uses the underlying hardware to generate random numbers. For convenience, the random number generator is also exposed to the API in to form of the <a class="el" href="group__embenet__node__api.html#gac888e7cfc2325ded0585ff924a11abec">EMBENET_NODE_GetRandomValue</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 19 2024 14:54:45 for embeNET NODE by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
